# Help Tramp and Eshell
[[ "${TERM}" = "dumb" ]] && unsetopt zle && PS1="$ " && return

# Automatic SSH agent
if ! pgrep -u "${USER}" ssh-agent > /dev/null; then
  ssh-agent -s | sed "s|^echo|#echo|" > "/tmp/ssh-agent.sh"
fi

if [[ ! "${SSH_AGENT_PID}" ]]; then
  source "/tmp/ssh-agent.sh"
fi

# Create cache directory
zsh_cache_dir="${HOME}/.cache/zsh"
[[ ! -d "${zsh_cache_dir}" ]] && mkdir -p "${zsh_cache_dir}"

# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

## Completion

# Load all stock functions to be called
autoload -U compaudit compinit bashcompinit zrecompile

# Set completion dump to cache dir
ZSH_COMPDUMP="${zsh_cache_dir}/zcompdump-${ZSH_VERSION}"

# Load completions from all directories
compinit -i -d "${ZSH_COMPDUMP}"

# zcompile the completion dump file if the .zwc is older or missing
if command mkdir "${ZSH_COMPDUMP}.lock" 2> /dev/null; then
  zrecompile -q -p "${ZSH_COMPDUMP}"
  command rm -rf "${ZSH_COMPDUMP}.lock"
fi

# Characters in this variable are considered part of a word. Leaving it empty
# will cause ZSH to treat most special characters as word delimiters
WORDCHARS=""

# If a completion is performed with the cursor within a word, and a full
# completion is inserted, the cursor is moved to the end of the word. That is,
# the cursor is moved to the end of the word if either a single match is
# inserted or menu completion is performed
setopt ALWAYS_TO_END

# The cursor stays and completion is done from both ends
setopt COMPLETE_IN_WORD

# [S-Tab] moves through the completion menu backwards
bindkey "^[[Z" reverse-menu-complete

# Highlight possible choices in the completion menu
zstyle ":completion:*" menu select

# Case and hyphen insensitive, partial-word and substring completion
zstyle ":completion:*" matcher-list \
  "m:{[:lower:][:upper:]-_}={[:upper:][:lower:]_-}" "r:|=*" "l:|=* r:|=*"

# Complete "." and ".." special directories
zstyle ":completion:*" special-dirs true

# By default, the completion system will expand // to /*/. Instead, squeeze
# slashes to /
zstyle ":completion:*" squeeze-slashes true

# Default coloring for GNU-based ls
source <(dircolors --sh)

# Colorize completion items based on $LS_COLORS
zstyle ":completion:*" list-colors "${(s.:.)LS_COLORS}"

# Colorize completion items for kill command completion
zstyle ":completion:*:*:kill:*:processes" list-colors \
  "=(#b) #([0-9]#) ([0-9a-z-]#)*=01;34=0=01"

# Use better list than the default one for the processes completion
zstyle ":completion:*:*:*:*:processes" command \
  "ps -u ${USERNAME} -o pid,user,comm -w -w"

# Print the type of the completion
zstyle ":completion:*:descriptions" format "[%d]"

# Print the possible corrections with more details
zstyle ":completion:*:corrections" format \
  "%B%F{yellow}!-- %d (errors: %e) --!%f%b"

# Show warning message when no completion is possible
zstyle ":completion:*:warnings" format "%F{red}No matches for:%f %B%d%b"

# Group the different type of matches under their descriptions
zstyle ":completion:*" group-name ""

# Activate approximate completion, but only after regular completion
zstyle ":completion:::::" completer _complete _approximate

# Allow one error per 3 character typed
zstyle ":completion:*:approximate:*" max-errors \
  'reply=( $(( ($#PREFIX+$#SUFFIX)/3 )) numeric )'

# Activate the completion caching layer for any completions which use it via the
# _store_cache, _retrieve_cache and _cache_invalid functions
zstyle ":completion:*" use-cache yes
zstyle ":completion:*" cache-path "${zsh_cache_dir}"

# Don't complete uninteresting users, e.g. for SSH command unless it's actually
# typed
zstyle ":completion:*:*:*:users" ignored-patterns \
  avahi bin daemon dbus ftp mail nobody polkitd sddm "systemd-*" tss usbmux \
  uuidd
zstyle ":completion:*" single-ignored show

function expand-or-complete-with-dots() {
  COMPLETION_WAITING_DOTS="%F{red}...%f"
  printf "\e[?7l%s\e[?7h" "${(%)COMPLETION_WAITING_DOTS}"
  zle expand-or-complete
  zle redisplay
}

zle -N expand-or-complete-with-dots
bindkey "^I" expand-or-complete-with-dots

# Load bash completion functions
bashcompinit

## Command line

# [Home], [End], [Delete] behaves as expected
bindkey "^[[H" beginning-of-line
bindkey "^[[F" end-of-line
bindkey "^[[1~" beginning-of-line
bindkey "^[[4~" end-of-line
bindkey "^[[3~" delete-char

# Use [M-a] and [M-e] for the same effect as [C-a] and [C-e] respectively
bindkey "^[a" beginning-of-line
bindkey "^[e" end-of-line

# Quickly jump to n-th arguments by pressing [M-number]
bindkey "^[1" beginning-of-line
bindkey -s "^[2" "^A^[f"
bindkey -s "^[3" "^A^[f^[f"
bindkey -s "^[4" "^A^[f^[f^[f"
bindkey -s "^[5" "^A^[f^[f^[f^[f"
bindkey -s "^[6" "^A^[f^[f^[f^[f^[f"
bindkey -s "^[7" "^A^[f^[f^[f^[f^[f^[f"
bindkey -s "^[8" "^A^[f^[f^[f^[f^[f^[f^[f"
bindkey -s "^[9" "^A^[f^[f^[f^[f^[f^[f^[f^[f"

# Use [C-u] to kill a whole line backwards
bindkey "^U" backward-kill-line

# Swap [M-h] with [C-M-h]
bindkey "^[^H" run-help
bindkey "^[H" backward-kill-word
bindkey "^[h" backward-kill-word

# Edit the current command line in $EDITOR with [C-x C-e]
autoload -U edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line

# Copy previous word with [M-m]
bindkey "^[m" copy-prev-shell-word

alias fu='sudo !!'

## Files and directories

# If a command is issued that can’t be executed as a normal command, and the
# command is the name of a directory, perform the cd command to that directory
setopt AUTO_CD

# Make cd push the old directory onto the directory stack
setopt AUTO_PUSHD

# Don’t push multiple copies of the same directory onto the directory stack
setopt PUSHD_IGNORE_DUPS

# Exchanges the meanings of "+" and "-" when used with a number to specify a
# directory in the stack
setopt PUSHD_MINUS

# Backup files
function bak() {
  for f in "$@"; do
    if [[ ! -e "${f}" ]]; then
      echo "No such file or directory: ${f}"
      continue
    fi
    f=$(echo "${f}" | sed "s|/*$||")
    if [[ -d "${f}" ]]; then
      echo rsync --archive --compress "${f}/" "${f}".bak
    else
      echo rsync --archive --compress "${f}" "${f}".bak
    fi
  done
}

# mkdir + cd
function mkcd() {
  mkdir -p "$@" && cd "${@:$#}" || return
}
compdef _mkdir mkcd

alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'
alias -g ......='../../../../..'

alias -- -='cd -'
alias 1='cd -1'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'
alias 6='cd -6'
alias 7='cd -7'
alias 8='cd -8'
alias 9='cd -9'

# Human readable outputs by default
alias df='df --human-readable'
alias free='free --human'

## Paging

# Automatically exit the second time it reaches end-of-file
LESS="--quit-at-eof"

# Automatically exit if the entire file can be displayed on the first screen
LESS="--quit-if-one-screen $LESS"

# Ignore case in searches; that is, uppercase and lowercase are considered
# identical. This option is ignored if any uppercase letters appear in the
# search pattern
LESS="--ignore-case $LESS"

# Prompt verbosely with the percent into the file
LESS="--LONG-PROMPT $LESS"

# Display "raw" control characters. The default is to display control characters
# using the caret notation
LESS="--RAW-CONTROL-CHARS $LESS"

# Disable sending the termcap initialization and deinitialization strings to the
# terminal. This is sometimes desirable if the deinitialization string does
# something unnecessary, like clearing the screen
LESS="--no-init $LESS"

# Temporarily highlight the first "new" line after a forward movement of a full
# page. The first "new" line is the line immediately following the line
# previously at the bottom of the screen. Also highlights the target line after
# a g or p command. The highlight is removed at the next command which causes
# movement
LESS="--hilite-unread $LESS"

# Change the default scrolling window size to WINDOW_SIZE-4 lines
LESS="--window=-4 $LESS"

# Specify the default number of positions to scroll horizontally in the
# RIGHTARROW and LEFTARROW commands
LESS="--shift 5 $LESS"

# Squeeze consecutive blank lines into a single blank line
LESS="--squeeze-blank-lines $LESS"
export LESS

## Editors

# Open the selected files with EDITOR or xdg-open with fd+fzf
function fe() {
  local key
  local -a files
  local out
  IFS=$'\n' out="$(fd --type=file "$1" \
    | fzf --select-1 --exit-0 --multi --expect=ctrl-o,ctrl-e)"
  key="$(head --lines=1 <<< "${out}")"
  files=($(tail --lines=+2 <<< "${out}"))
  if [[ -z ${files} ]]; then return; fi
  for i in {1..$#files}; do files[${i}]="\"${files[${i}]}\""; done
  if [[ "${key}" = "ctrl-o" ]]; then
    for file in ${files}; do xdg-open "${file}"; done
  else
    eval "${EDITOR} ${files[@]}"
  fi
}

# Fuzzy grep open via ripgrep
function eg() {
  local file
  local line
  local column
  local -a out
  if [[ "$#" == 0 ]]; then return 1; fi
  if [[ "${EDITOR}" =~ emacs ]]; then
    out=(${(f)"$(rg --no-heading --column --line-number --color=always "$@" \
      | fzf --ansi --select-1 --exit-0 --multi \
      | awk -F: '{printf "%s:%s:%s\n", $1, $2, $3}')"})
  else
    out=(${(f)"$(rg --no-heading --column --line-number --color=always "$@" \
      | fzf --ansi --select-1 --exit-0 --multi \
      | awk -F: '{printf "%s:%s:%s\n", $1, $2, $3}')"})
  fi
  if [[ -z ${out} ]]; then return; fi
  eval "${EDITOR} ${out[@]}"
}

# Fuzzy grep open with preview via ripgrep
function egp() {
  local -a files
  if [[ "$#" == 0 ]]; then return 1; fi
  IFS=$'\n' files=($(rg --max-count=1 --files-with-matches --no-messages "$@" \
    | fzf --select-1 --exit-0 --multi \
      --preview="rg --pretty --context=10 $* {}"))
  if [[ -z ${files} ]]; then return; fi
  for i in {1..$#files}; do files[${i}]="\"${files[${i}]}\""; done
  [[ -n "${files}" ]] && eval "${EDITOR} ${files[@]}"
}

# Set both EDITOR and VISUAL to emacsclient with autostarted server
export EDITOR="emacsclient --tty"
export VISUAL="$EDITOR"

# emacsclient starts emacs in daemon mode if it can't connect to it
export ALTERNATE_EDITOR=""

alias ec='emacsclient --tty'
alias ecg='emacsclient --create-frame --no-wait'
alias mg='ec --eval "(magit-status)"'
alias mgg='ecg --eval "(magit-status)"'

alias e='emacs'

## Expansion and Globbing

# All unquoted arguments of the form "anything=expression" appearing after the
# command name have filename expansion, (that is, where expression has a leading
# "~" or "=") performed on expression as if it were a parameter assignment
setopt MAGIC_EQUAL_SUBST

## History

zsh_state_dir="${HOME}/.local/state/zsh"
export HISTFILE="${zsh_state_dir}/history"
export HISTSIZE=1000000
export SAVEHIST=500000
[[ ! -d "${zsh_state_dir}" ]] && mkdir -p "${zsh_state_dir}"

# Save each command’s beginning timestamp (in seconds since the epoch) and the
# duration (in seconds) to the history file
setopt EXTENDED_HISTORY

# If the history needs to be trimmed to add the current command line, cause the
# oldest history event that has a duplicate to be lost before losing a unique
# event from the list
setopt HIST_EXPIRE_DUPS_FIRST

# Do not enter command lines into the history list if they are duplicates of the
# previous event
setopt HIST_IGNORE_DUPS

# Remove command lines from the history list when the first character on the
# line is a space, or when one of the expanded aliases contains a leading space.
# Only normal aliases (not global or suffix aliases) have this behavior
setopt HIST_IGNORE_SPACE

# Remove the history (fc -l) command from the history list when invoked
setopt HIST_NO_STORE

# Remove superfluous blanks from each command line being added to the history
# list
setopt HIST_REDUCE_BLANKS

# Whenever the user enters a line with history expansion, don’t execute the line
# directly; instead, perform history expansion and reload the line into the
# editing buffer
setopt HIST_VERIFY

# Import new commands from the history file, and also make typed commands to be
# appended to the history file
setopt SHARE_HISTORY

# [Up] and [Down] cycles through history based on characters already typed on
# the line
autoload -U up-line-or-beginning-search
autoload -U down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey "^[[A" up-line-or-beginning-search
bindkey "^[[B" down-line-or-beginning-search

# [PageUp] and [PageDown] for navigating history
bindkey "^[[5~" up-line-or-history
bindkey "^[[6~" down-line-or-history

## Input/Output

# Output flow control via start/stop characters (usually assigned to ^S/^Q) is
# disabled in the shell’s editor
unsetopt FLOW_CONTROL

# Allow comments even in interactive shells
setopt INTERACTIVE_COMMENTS

# Do not query the user before executing "rm *" or "rm path/*"
setopt RM_STAR_SILENT

## Job Control

# Print job notifications in the long format by default
setopt LONG_LIST_JOBS

## Git

# Print Git master branch
function git-master-branch() {
  git rev-parse --git-dir &> /dev/null || return
  local ref
  for ref in refs/heads/{master,main,trunk}; do
    if git show-ref --quiet --verify "${ref}"; then
      echo "${ref#refs/heads/}"
      return
    fi
  done
}

# Print Git develop branch
function git-develop-branch() {
  git rev-parse --git-dir &> /dev/null || return
  local branch
  for ref in refs/heads/{dev,devel,develop}; do
    if git show-ref --quiet --verify "${ref}"; then
      echo "${ref#refs/heads/}"
      return
    fi
  done
}

# Commit all changes in Git tree
function git-wip() {
  git add --all || return 128
  git rm $(git ls-files --deleted) 2> /dev/null
  git commit --no-verify --no-gpg-sign --message "--wip--"
}

# Reset last commit if it was WIP
function git-unwip() {
  git rev-list --max-count=1 --format="%s" HEAD | grep --quiet "\--wip--" \
  && git reset HEAD~1
}

# Reset all WIP commits
function git-unwip-all() {
  local commit=$(git log --grep="--wip--" --invert-grep --max-count=1 \
                     --format=format:%H)
  if [[ "${commit}" != "$(git rev-parse HEAD)" ]]; then
    git reset "${commit}" || return 1
  fi
}

alias ga='git add'
alias gaa='git add --all'
alias gap='git add --patch'
alias gau='git add --update'

alias gbs='git bisect'
alias gbsb='git bisect bad'
alias gbsg='git bisect good'
alias gbsr='git bisect reset'
alias gbss='git bisect start'

alias gbl='git blame -w'

alias gb='git branch'
alias gba='git branch --all'
alias gbd='git branch --delete'
alias gbD='git branch --delete --force'
alias gbg='git branch -vv | grep ": gone\]"'
alias gbm='git branch --move'
alias gbnm='git branch --no-merged'
alias gbr='git branch --remote'

alias gco='git checkout'
alias gcd='git checkout $(git-develop-branch)'
alias gcm='git checkout $(git-master-branch)'

alias gcp='git cherry-pick'
alias gcpa='git cherry-pick --abort'
alias gcpc='git cherry-pick --continue'

alias gclean='git clean --interactive -d'
alias gcl='git clone --recurse-submodules'

alias gc='git commit'
alias gcs='git commit --gpg-sign'
alias gcss='git commit --gpg-sign --signoff'
alias gc!='git commit --amend'
alias gcn!='git commit --no-edit --amend'
alias gcs!='git commit --gpg-sign --amend'
alias gcss!='git commit --gpg-sign --signoff --amend'

alias gcf='git config --list'
alias gdct='git describe --tags $(git rev-list --tags --max-count=1)'

alias gd='git diff'
alias gd2='git -c delta.side-by-side=true diff'
alias gdn='git -c delta.navigate=true diff'
alias gdn2='git -c delta.navigate=true -c delta.side-by-side=true diff'
alias gds='git diff --staged'
alias gds2='git -c delta.side-by-side=true diff --staged'
alias gdsn='git -c delta.navigate=true diff --staged'
alias gdsn2='git -c delta.navigate=true -c delta.side-by-side=true diff --staged'
alias gdt='git -c diff.external=difft diff'
alias gdst='git -c diff.external=difft diff --staged'
alias gdw='git diff --word-diff'
alias gdsw='git diff --staged --word-diff'
alias gdu='git diff @{upstream}'
alias gduc='git diff @ @{upstream}'
alias gdtool='git difftool'
alias gdtoolg='git difftool --gui'

alias gf='git fetch'

alias gcount='git shortlog --summary --numbered'
alias glg='git log --stat'
alias glgp='git log --stat --patch'
alias glod='git log --graph --pretty="%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)<%an>%Creset"'
alias glol='git log --graph --pretty="%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset"'
alias glola='git log --graph --pretty="%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset" --all'
alias glols='git log --graph --pretty="%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset" --stat'
alias glo='git log --oneline'
alias glog='git log --oneline --graph --all'

alias gignored='git ls-files --others'

alias gm='git merge'
alias gmff='git merge --ff-only'
alias gma='git merge --abort'
alias gmc='git merge --continue'
alias gms='git merge --squash'
alias gmtool='git mergetool'
alias gmtoolg='git mergetool --gui'

alias gl='git pull'

alias gp='git push'
alias gpf='git push --force-with-lease --force-if-includes'

alias grb='git rebase'
alias grba='git rebase --abort'
alias grbc='git rebase --continue'
alias grbi='git rebase --interactive'
alias grbo='git rebase --onto'
alias grbs='git rebase --skip'
alias grbd='git rebase $(git-develop-branch)'
alias grbm='git rebase $(git-master-branch)'
alias grbod='git rebase origin/$(git-develop-branch)'
alias grbom='git rebase origin/$(git-master-branch)'
alias grbud='git rebase upstream/$(git-develop-branch)'
alias grbum='git rebase upstream/$(git-master-branch)'

alias grv='git remote --verbose'

alias gpristine='git reset --hard && git clean --force -dfx'
alias grh='git reset'
alias grhh='git reset --hard'
alias grhu='git reset --hard @{upstream}'
alias grhk='git reset --keep'
alias grhs='git reset --soft'

alias grs='git restore'
alias grss='git restore --source'
alias grst='git restore --staged'

alias grev='git revert'
alias grm='git rm'
alias grmc='git rm --cached'

alias gsh='git show'

alias gsta='git stash push'
alias gstaa='git stash apply'
alias gstall='git stash --all'
alias gstc='git stash clear'
alias gstd='git stash drop'
alias gstl='git stash list'
alias gstp='git stash pop'
alias gsts='git stash show --patch'
alias gstu='git stash push --include-untracked'

alias gst='git status'
alias gsl='git status --long'

alias gsi='git submodule init'
alias gsu='git submodule update'

alias gsd='git switch $(git-develop-branch)'
alias gsm='git switch $(git-master-branch)'
alias gsw='git switch'
alias gswc='git switch --create'
alias gswd='git switch --detach'

alias gta='git tag --annotate'
alias gts='git tag --sign'
alias gtv='git tag | sort -V'

alias gignore='git update-index --skip-worktree'
alias gunignore='git update-index --no-skip-worktree'

alias gwt='git worktree'
alias gwta='git worktree add'
alias gwtls='git worktree list'
alias gwtmv='git worktree move'
alias gwtrm='git worktree remove'

alias gwip='git-wip'
alias gunwip='git-unwip'
alias gunwipall='git-unwip-all'

## Bat

# Use bat as MANPAGER
export MANPAGER="sh -c 'col -b | bat -l man -p'"
export MANROFFOPT="-c"

# Use bat instead of cat by default
alias cat='bat'

# Use bat to colorize help messages
function help() {
  if [[ "$#" == 0 ]]; then return 1; fi
  "$1" --help | bat --plain --language=help
}

alias -g -- -h='-h 2>&1 | bat -plain --language=help'
alias -g -- --help='--help 2>&1 | bat --plain --language=help'

## CMake

# By default, use nproc number of threads
export CMAKE_BUILD_PARALLEL_LEVEL=$(nproc)

# Generates compile_commands.json by default
export CMAKE_EXPORT_COMPILE_COMMANDS=ON

# Use Ninja by default
export CMAKE_GENERATOR=Ninja

# Use sccache by default
export CMAKE_C_COMPILER_LAUNCHER="sccache"
export CMAKE_CXX_COMPILER_LAUNCHER="sccache"

# Output should be logged for failed tests
export CTEST_OUTPUT_ON_FAILURE=ON

# Report CTest progress by repeatedly updating the same line
export CTEST_PROGRESS_OUTPUT=ON

## Dua

alias du='dua'

## Fzf

# Set fd as the default source for fzf
export FZF_DEFAULT_COMMAND="fd \
--hidden \
--follow \
--exclude='.git/' \
"

# Default fzf options
export FZF_DEFAULT_OPTS=" \
--height=60% \
--bind alt-p:preview-up,alt-n:preview-down \
--bind ctrl-alt-p:preview-half-page-up,ctrl-alt-n:preview-half-page-down \
--bind alt-up:preview-half-page-up,alt-down:preview-half-page-down \
--bind ctrl-v:half-page-down,alt-v:half-page-up \
--bind alt-a:select-all,ctrl-alt-a:deselect-all,alt-t:toggle-all \
"

# Paste selected files and directories onto the command line with [C-t]
export FZF_CTRL_T_COMMAND="${FZF_DEFAULT_COMMAND}"

# Change directory with preview with [M-c]
export FZF_ALT_C_COMMAND="fd \
--follow \
--type directory \
"
export FZF_ALT_C_OPTS="--preview 'tree -C {} | head -200'"

if (( ${+commands[fzf]} )); then
  fzf_init="${zsh_cache_dir}/fzf-init.zsh"
  if [[ "${commands[fzf]}" -nt "${fzf_init}" || ! -s "${fzf_init}" ]]; then
    fzf --zsh >| "${fzf_init}"
  fi
  source "${fzf_init}"
  unset -v fzf_init
fi

## Lsd

alias ls='lsd'
alias ll='ls --long'
alias la='ll --almost-all'
alias l='la --git'

## Kitty

# Ensures that terminfo is uploaded
alias ssh='kitty +kitten ssh'

# Nicer scp/rsync
alias transfer='kitty +kitten transfer'

## Ninja

# Include the current load to the ninja status
export NINJA_STATUS="[%s/%f/%t] (j%r/%e) "

## Ripgrep

# Grep with syntax highlighting.
function rgd {
  if [[ "$#" == 0 ]]; then return 1; fi
  rg --json --context=3 "$@" | delta
}

## Rsync

alias cpv='rsync-copy'
alias rsync-copy='rsync --archive --compress -hhh --progress'
alias rsync-move='rsync-copy --remove-source-files'
alias rsync-update='rsync-copy --update'
alias rsync-synchronize='rsync-update --delete'

## SSH

# Copy current terminfo file to the given host
function ssh-copy-terminfo() {
  if [[ "$#" == 0 ]]; then return 1; fi
  infocmp -a | ssh "$1" tic -x -o \~/.terminfo /dev/stdin
}

## Tig

alias tia='tig --all'

function tig-widget() {
  tig

  local fn
  for fn (chpwd $chpwd_functions precmd $precmd_functions); do
    (( $+functions[$fn] )) && $fn
  done
  zle reset-prompt
}

zle -N tig-widget
bindkey "^[g" tig-widget

## Yazi

# Start Yazi but change CWD after exit
function y() {
  local tempfile
  local IFS=$'\t\n'
  temp="$(mktemp -t yazi-cwd.XXXXX)"

  yazi "$@" --cwd-file="${temp}"
  if cwd="$(cat -- "${temp}")" \
    && [[ -n "${cwd}" ]] \
    && [[ "${cwd}" != "${PWD}" ]]; then
    builtin cd -- "${cwd}" || return
  fi
  command rm -f -- "${temp}" 2> /dev/null
}

function y-widget() {
  y

  local fn
  for fn (chpwd $chpwd_functions precmd $precmd_functions); do
    (( $+functions[$fn] )) && $fn
  done
  zle reset-prompt
}

zle -N y-widget
bindkey "^O" y-widget

### Zoxide

if (( ${+commands[zoxide]} )); then
  zoxide_init="${zsh_cache_dir}/zoxide-init.zsh"
  if [[ "${commands[zoxide]}" -nt "${zoxide_init}" \
          || ! -s "${zoxide_init}" ]]; then
    zoxide init zsh --cmd cd --hook prompt >| "${zoxide_init}"
  fi
  source "${zoxide_init}"
  unset -v zoxide_init
fi

## Plugins

### Dircycle

# Use [M-S-Left] and [M-S-Right] for dircycle
bindkey "^[[1;4D" insert-cycledleft
bindkey "^[[1;4C" insert-cycledright

### Fzf-Tab

# Switch group using F1 and F2
zstyle ":fzf-tab:*" switch-group F1 F2

# Disable prefix before colorized completions
zstyle ":fzf-tab:*" prefix ""

### Zsh-Autosuggestion

# Change to slightly more visible color when highlighting a suggestion
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=60"

# Set max size of buffer to trigger autosuggestion. This can be useful when
# pasting large amount of text in the terminal, to avoid triggering
# autosuggestion for strings that are too long
ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=40

# Try to find a suggestion from the history, but, if it can't find a match, will
# find a suggestion from the completion engine
ZSH_AUTOSUGGEST_STRATEGY=(history completion)

### Theme

# Define character set used by powerlevel10k
POWERLEVEL9K_MODE=nerdfont-v3

# Default colors of dir segment
POWERLEVEL9K_DIR_BACKGROUND=blue
POWERLEVEL9K_DIR_FOREGROUND=brightwhite

# If directory is too long, shorten some of its segments to the shortest
# possible unique prefix. The shortened directory can be tab-completed to the
# original
POWERLEVEL9K_SHORTEN_STRATEGY=truncate_to_unique

# Color of the shortened directory entries
POWERLEVEL9K_DIR_SHORTENED_FOREGROUND=248

# Shorten directory if it's longer than this even if there is space for it. The
# value can be either absolute (e.g., '80') or a percentage of terminal width
# (e.g, '50%'). If empty, directory will be shortened only when prompt doesn't
# fit or when other parameters demand it. If set to 0, directory will always be
# shortened to its minimum length
POWERLEVEL9K_DIR_MAX_LENGTH=50%

# Display anchor directory segments in bold
POWERLEVEL9K_DIR_ANCHOR_BOLD=true

# Don't shorten directories that contain any of these entries
anchors=(
  .git
  .svn
)
POWERLEVEL9K_SHORTEN_FOLDER_MARKER="(${(j:|:)anchors})"
unset -v anchors

# Colors of writable segment
POWERLEVEL9K_DIR_WRITABLE_FORBIDDEN_BACKGROUND=red
POWERLEVEL9K_DIR_WRITABLE_FORBIDDEN_FOREGROUND=white

# Colors of vcs segment that depends on its state
POWERLEVEL9K_VCS_CLEAN_BACKGROUND=076
POWERLEVEL9K_VCS_CLEAN_FOREGROUND=black
POWERLEVEL9K_VCS_UNTRACKED_BACKGROUND=076
POWERLEVEL9K_VCS_UNTRACKED_FOREGROUND=black
POWERLEVEL9K_VCS_MODIFIED_BACKGROUND=220
POWERLEVEL9K_VCS_MODIFIED_FOREGROUND=black

# Don't show standard Powerline branch icon
POWERLEVEL9K_HIDE_BRANCH_ICON=true

# Show status of repositories of these types
POWERLEVEL9K_VCS_BACKENDS=(git)

# Enable counters for staged, unstaged, etc.
POWERLEVEL9K_VCS_STAGED_MAX_NUM=-1
POWERLEVEL9K_VCS_UNSTAGED_MAX_NUM=-1
POWERLEVEL9K_VCS_UNTRACKED_MAX_NUM=-1
POWERLEVEL9K_VCS_CONFLICTED_MAX_NUM=-1
POWERLEVEL9K_VCS_COMMITS_AHEAD_MAX_NUM=-1
POWERLEVEL9K_VCS_COMMITS_BEHIND_MAX_NUM=-1

# Don't show status on success
POWERLEVEL9K_STATUS_OK=false

# Colors of error status
POWERLEVEL9K_STATUS_ERROR_BACKGROUND=red
POWERLEVEL9K_STATUS_ERROR_FOREGROUND=226

# Colors of background jobs
POWERLEVEL9K_BACKGROUND_JOBS_BACKGROUND=black
POWERLEVEL9K_BACKGROUND_JOBS_FOREGROUND=cyan

# Colors of execution time
POWERLEVEL9K_COMMAND_EXECUTION_TIME_BACKGROUND=245
POWERLEVEL9K_COMMAND_EXECUTION_TIME_FOREGROUND=black

# Show duration of the last command if it takes at least this many seconds
POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD=2

# The list of segments shown on the left
POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(
  root_indicator
  dir
  dir_writable
  vcs
)

# The list of segments shown on the right
POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(
  status
  background_jobs
  command_execution_time
)

# Add an empty line before each prompt
POWERLEVEL9K_PROMPT_ADD_NEWLINE=true

# Position prompt on a newline
POWERLEVEL9K_PROMPT_ON_NEWLINE=true

# Filler between left and right prompt on the first prompt line
POWERLEVEL9K_MULTILINE_FIRST_PROMPT_GAP_CHAR=·

# The color of the filler
POWERLEVEL9K_MULTILINE_FIRST_PROMPT_GAP_FOREGROUND=244

# Transient prompt works similarly to the builtin transient_rprompt option - it
# trims down prompt when accepting a command line. Supported values:
#   - off:      Don't change prompt when accepting a command line.
#   - always:   Trim down prompt when accepting a command line.
#   - same-dir: Trim down prompt when accepting a command line unless this is
#               the first command typed after changing current working
#               directory
POWERLEVEL9K_TRANSIENT_PROMPT=same-dir

### Sheldon

# Load all plugins
eval "$(sheldon source)"

unset -v zsh_cache_dir
unset -v zsh_state_dir
